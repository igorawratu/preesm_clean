#include "clean.h"

#include <algorithm>
#include <limits>
#include <assert.h>

void FindPeak(std::uint32_t img_width, std::uint32_t img_height, float* img, std::uint32_t& peak_x, std::uint32_t& peak_y, float& peak_val){
	assert(img_width > 0 && img_height > 0);

	peak_val = -std::numeric_limits<float>::max();

	for(std::uint32_t y = 0; y < img_width; ++y){
		for(std::uint32_t x = 0; x < img_width; ++x){
			curr_idx = x + y * img_height; //might want to change this to a morton code hash or something for better cache coherency
			if(peak_val < img[curr_idx]){
				peak_val = img[curr_idx];
				peak_x = x;
				peak_y = y;
			}
		}
	}
}

void AddToModel(std::uint32_t model_width, std::uint32_t model_height, float* model, std::uint32_t x, std::uint32_t y, float& peak_val){
	assert(x < model_width && y < model_height);

	model[x + y * model_width] += peak_val;
}

void SubtractBeamAt(std::uint32_t img_width, std::uint32_t img_height, float* img, std::uint32_t beam_width, std::uint32_t beam_height, float* beam,
		std::uint32_t x, std::uint32_t y, float gain){
	assert(x < img_width && y < img_height);

	std::uint32_t
}

void Convolve2D(std::uint32_t img_width, std::uint32_t img_height, float* img, std::uint32_t kernel_width, std::uint32_t kernel_height, float* kernel,
		CONVOLUTION_TYPE conv_type){

}

void DisplayImage(std::uint32_t img_width, std::uint32_t img_height, float* img){

}
